<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GPU Path Tracer — PingPong Accumulation</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  #glcanvas { display:block; width:100vw; height:100vh; }
  #msg { position:fixed; left:8px; top:8px; color:#ddd; font-family:monospace; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="msg">Initializing…</div>

<script>
/* Ping-pong accumulation path tracer (WebGL2).
   - No additive blending: safe ping-pong of two RGBA32F textures.
   - Single-sample-per-frame (fast interactivity) — can be increased later.
   - WebGL2 + EXT_color_buffer_float required.
*/

const VERT_SRC = `#version 300 es
in vec2 a_pos;
out vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

// Sample+Accumulate shader: reads previous accumulation texture and writes prev + sample
const FRAG_SAMPLE_SRC = `#version 300 es
precision highp float;
precision highp int;
in vec2 v_uv;
out vec4 outColor;

uniform sampler2D u_prevAccum;
uniform vec2 u_resolution;
uniform int u_frame;
uniform vec3 u_camPos;
uniform vec3 u_camForward;
uniform vec3 u_camRight;
uniform vec3 u_camUp;
uniform float u_fov;
uniform float u_aspect;

#define MAX_SPH 8
#define MAX_LIGHTS 8
uniform int u_sphereCount;
uniform vec4 u_spheres[MAX_SPH];
uniform int u_sphereMatIdx[MAX_SPH];
uniform int u_matCount;
uniform vec3 u_mats[16];
uniform int u_lightCount;
uniform vec4 u_lights[MAX_LIGHTS];
uniform vec3 u_lightCols[MAX_LIGHTS];

const float PI = 3.141592653589793;
const float SHADOW_BIAS = 0.001;
const float TRACE_LIMIT = 15.0;

uint wang_hash(uint seed) {
  seed = (seed ^ 61u) ^ (seed >> 16);
  seed *= 9u;
  seed = seed ^ (seed >> 4);
  seed *= 0x27d4eb2du;
  seed = seed ^ (seed >> 15);
  return seed;
}
float rnd(inout uint state) {
  state = wang_hash(state);
  return float(state) / 4294967296.0;
}

struct Hit {
  float t;
  int hitType;
  int mat;
  vec3 pos;
  vec3 n;
};

Hit intersectScene(vec3 ro, vec3 rd) {
  Hit res; res.t = 1e20; res.hitType = 0; res.mat = 0;
  for (int i=0;i<MAX_SPH;i++){
    if(i>=u_sphereCount) break;
    vec4 s = u_spheres[i];
    vec3 oc = vec3(s.x,s.y,s.z) - ro;
    float b = dot(oc, rd);
    if (b < 0.0) continue;
    float r2 = s.w*s.w;
    float d2 = dot(oc,oc) - b*b;
    if (d2 > r2) continue;
    float t = b - sqrt(max(0.0, r2 - d2));
    if (t > 0.001 && t < res.t) {
      res.t = t; res.hitType = 1; res.mat = u_sphereMatIdx[i];
      res.pos = ro + rd * t; res.n = normalize(res.pos - vec3(s.x,s.y,s.z));
    }
  }
  float py = -0.5;
  if (abs(rd.y) > 1e-6) {
    float t = (py - ro.y) / rd.y;
    if (t > 0.001 && t < res.t) {
      res.t = t; res.hitType = 2; res.mat = 3;
      res.pos = ro + rd * t; res.n = vec3(0.0,1.0,0.0);
      float cx = floor(res.pos.x);
      float cz = floor(res.pos.z);
      if (mod(cx + cz, 2.0) != 0.0) res.mat = 4;
    }
  }
  return res;
}

bool intersectShadow(vec3 ro, vec3 rd, float maxDist){
  for (int i=0;i<MAX_SPH;i++){
    if(i>=u_sphereCount) break;
    vec4 s = u_spheres[i];
    vec3 oc = vec3(s.x,s.y,s.z) - ro;
    float b = dot(oc, rd);
    if (b < 0.0) continue;
    float r2 = s.w*s.w;
    float d2 = dot(oc,oc) - b*b;
    if (d2 > r2) continue;
    float t = b - sqrt(max(0.0, r2 - d2));
    if (t > SHADOW_BIAS && t < maxDist) return true;
  }
  float py = -0.5;
  if (abs(rd.y) > 1e-6) {
    float t = (py - ro.y) / rd.y;
    if (t > SHADOW_BIAS && t < maxDist) return true;
  }
  return false;
}

vec3 sampleHemisphere(vec3 n, float u1, float u2) {
  float r = sqrt(u1);
  float theta = 2.0 * PI * u2;
  vec3 tangent = abs(n.x) > 0.1 ? normalize(cross(n, vec3(0.0,1.0,0.0))) : normalize(cross(n, vec3(1.0,0.0,0.0)));
  vec3 bit = cross(n, tangent);
  return normalize(tangent * (r * cos(theta)) + bit * (r * sin(theta)) + n * sqrt(max(0.0, 1.0 - u1)));
}

void main(){
  // previous accumulation
  vec3 prev = texture(u_prevAccum, v_uv).rgb;

  ivec2 ip = ivec2(gl_FragCoord.xy);
  uint seed = uint(u_frame) * 1973u + uint(ip.x) * 9277u + uint(ip.y) * 2663u + 0x9e3779b9u;
  float jx = rnd(seed), jy = rnd(seed);

  vec2 pixel = v_uv * u_resolution;
  vec2 uv = (pixel + vec2(jx,jy)) / u_resolution;
  float ndcY = (1.0 - uv.y) * 2.0 - 1.0;
  float ndcX = (uv.x * 2.0 - 1.0) * u_aspect;

  float vpH = 2.0 * tan(u_fov * 0.5);
  vec3 rayDir = normalize(u_camForward + u_camRight * ndcX * vpH * 0.5 + u_camUp * ndcY * vpH * 0.5);
  vec3 ro = u_camPos;
  vec3 rd = rayDir;

  vec3 acc = vec3(0.0);
  vec3 mask = vec3(1.0);

  for (int depth=0; depth<4; depth++){
    Hit h = intersectScene(ro, rd);
    if (h.hitType == 0){
      float t = 0.5 * (rd.y + 1.0);
      vec3 sky = mix(vec3(0.7,0.8,1.0)*0.1 + vec3(0.6,0.7,0.8)*0.6, vec3(0.1,0.1,0.3), t);
      acc += mask * sky;
      break;
    }
    vec3 matCol = u_mats[h.mat];
    if (h.t > TRACE_LIMIT && depth == 0){
      float fake = 0.2 + max(0.0, h.n.y) * 0.8;
      acc += mask * matCol * fake;
      break;
    }

    if (u_lightCount > 0) {
      int li = int(floor(rnd(seed) * float(u_lightCount)));
      li = clamp(li, 0, u_lightCount-1);
      vec4 L = u_lights[li];
      vec3 Lcol = u_lightCols[li];

      float ar1 = rnd(seed) * 2.0 * PI;
      float ar2 = rnd(seed);
      float r = L.w * sqrt(ar2);
      vec3 pOnLight = vec3(L.x, L.y, L.z) + vec3(r * cos(ar1), r * sin(ar1), 0.0);

      vec3 ldir = pOnLight - (h.pos + h.n * SHADOW_BIAS);
      float dist2 = dot(ldir, ldir);
      float dist = sqrt(dist2);
      ldir /= dist;
      float ndotl = max(0.0, dot(ldir, h.n));
      if (ndotl > 0.0 && !intersectShadow(h.pos + h.n * SHADOW_BIAS, ldir, dist - 0.01)) {
        float intensity = ndotl / dist2;
        acc += mask * matCol * Lcol * intensity * 4.0;
      }
    }

    float u1 = rnd(seed);
    float u2 = rnd(seed);
    vec3 newDir = sampleHemisphere(h.n, u1, u2);
    ro = h.pos + h.n * SHADOW_BIAS;
    rd = newDir;
    mask *= matCol;

    if (depth >= 2) {
      float p = max(mask.r, max(mask.g, mask.b));
      if (rnd(seed) > p) break;
      mask /= p;
    }
  }

  vec3 outAccum = prev + acc;
  outColor = vec4(outAccum, 1.0);
}
`;

// Display pass: show accum / frameCount with gamma (sqrt)
const FRAG_DISPLAY_SRC = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;
uniform sampler2D u_accum;
uniform int u_frame;
void main(){
  vec3 sum = texture(u_accum, v_uv).rgb;
  float f = max(1, u_frame);
  vec3 col = sum / float(f);
  col = sqrt(col);
  outColor = vec4(col, 1.0);
}
`;

// GL helpers
function createShader(gl, type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    const log = gl.getShaderInfoLog(s);
    console.error("Shader compile error", log);
    throw new Error(log);
  }
  return s;
}
function createProgram(gl, vsSrc, fsSrc){
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    const log = gl.getProgramInfoLog(p);
    console.error("Program link error", log);
    throw new Error(log);
  }
  return p;
}

const canvas = document.getElementById('glcanvas');
const msg = document.getElementById('msg');
const gl = canvas.getContext('webgl2', { antialias:false });
if(!gl){ msg.textContent = "WebGL2 unsupported."; throw new Error("No WebGL2"); }
const ext = gl.getExtension('EXT_color_buffer_float');
if(!ext){ msg.textContent = "EXT_color_buffer_float missing."; throw new Error("No ext"); }

// quad
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

// programs
const progSample = createProgram(gl, VERT_SRC, FRAG_SAMPLE_SRC);
const progDisplay = createProgram(gl, VERT_SRC, FRAG_DISPLAY_SRC);

// scene (from your original)
const SPHERES = [
  {cx: 0, cy: 0.5, cz: -0.5, rad: 1.0, mat: 0},
  {cx: 1.8, cy: 0.2, cz: 0.5, rad: 0.7, mat: 1},
  {cx: -1.8, cy: 0.2, cz: 0.0, rad: 0.7, mat: 2}
];
const MATERIALS = [
  {r:0.9,g:0.2,b:0.2},
  {r:0.7,g:0.7,b:0.7},
  {r:0.2,g:0.3,b:0.9},
  {r:0.9,g:0.9,b:0.9},
  {r:0.1,g:0.1,b:0.1}
];
const LIGHTS = [
  {x:-5,y:8,z:5,rad:1.5, r:15,g:15,b:15},
  {x:5,y:5,z:2,rad:1.0, r:5,g:5,b:5}
];

function setSceneUniforms(gl, prog){
  gl.useProgram(prog);
  gl.uniform1i(gl.getUniformLocation(prog, "u_sphereCount"), Math.min(8, SPHERES.length));
  const spheresArr = new Float32Array(4*8);
  const matIdx = new Int32Array(8);
  for(let i=0;i<Math.min(8,SPHERES.length);i++){
    const s = SPHERES[i];
    spheresArr[i*4+0] = s.cx; spheresArr[i*4+1] = s.cy; spheresArr[i*4+2] = s.cz; spheresArr[i*4+3] = s.rad;
    matIdx[i] = s.mat|0;
  }
  gl.uniform4fv(gl.getUniformLocation(prog, "u_spheres"), spheresArr);
  gl.uniform1iv(gl.getUniformLocation(prog, "u_sphereMatIdx"), matIdx);

  gl.uniform1i(gl.getUniformLocation(prog, "u_matCount"), MATERIALS.length);
  const matsArr = new Float32Array(3*16);
  for(let i=0;i<MATERIALS.length;i++){
    matsArr[i*3+0] = MATERIALS[i].r; matsArr[i*3+1] = MATERIALS[i].g; matsArr[i*3+2] = MATERIALS[i].b;
  }
  gl.uniform3fv(gl.getUniformLocation(prog, "u_mats"), matsArr);

  const lc = Math.min(8, LIGHTS.length);
  gl.uniform1i(gl.getUniformLocation(prog, "u_lightCount"), lc);
  const lightsArr = new Float32Array(4*8);
  const lcolsArr = new Float32Array(3*8);
  for(let i=0;i<lc;i++){
    const L = LIGHTS[i];
    lightsArr[i*4+0] = L.x; lightsArr[i*4+1] = L.y; lightsArr[i*4+2] = L.z; lightsArr[i*4+3] = L.rad;
    lcolsArr[i*3+0] = L.r; lcolsArr[i*3+1] = L.g; lcolsArr[i*3+2] = L.b;
  }
  gl.uniform4fv(gl.getUniformLocation(prog, "u_lights"), lightsArr);
  gl.uniform3fv(gl.getUniformLocation(prog, "u_lightCols"), lcolsArr);
}
setSceneUniforms(gl, progSample);

// ping-pong accumulation textures and FBO
let accumTex = [null, null];
let accumFBO = gl.createFramebuffer();
let w = 1, h = 1;
function createAccumTextures(newW, newH){
  w = newW; h = newH;
  for(let i=0;i<2;i++){
    if(accumTex[i]) gl.deleteTexture(accumTex[i]);
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, w, h, 0, gl.RGBA, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    accumTex[i] = t;
  }
  // clear both to zero
  gl.bindFramebuffer(gl.FRAMEBUFFER, accumFBO);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, accumTex[0], 0);
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, accumTex[1], 0);
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function bindQuadAttribs(gl, prog){
  const loc = gl.getAttribLocation(prog, "a_pos");
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

// DPR-aware resize
function resize(){
  const dpr = window.devicePixelRatio || 1;
  const cw = Math.max(1, Math.floor(window.innerWidth * dpr));
  const ch = Math.max(1, Math.floor(window.innerHeight * dpr));
  canvas.width = cw; canvas.height = ch;
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  gl.viewport(0,0,cw,ch);
  createAccumTextures(cw,ch);
  frameCount = 0;
  curIdx = 0; nextIdx = 1;
}
window.addEventListener('resize', resize);

// camera and interaction
let cam = { dist:7.0, azi: Math.PI/2 + 0.5, ele:0.4, target:{x:0,y:0.2,z:0} };
function computeCam(){
  const y = cam.dist * Math.sin(cam.ele);
  const r = cam.dist * Math.cos(cam.ele);
  const camX = cam.target.x + r * Math.sin(cam.azi);
  const camY = cam.target.y + y;
  const camZ = cam.target.z + r * Math.cos(cam.azi);
  let fx = cam.target.x - camX, fy = cam.target.y - camY, fz = cam.target.z - camZ;
  const fl = Math.hypot(fx,fy,fz); fx/=fl; fy/=fl; fz/=fl;
  let rx = fz, ry = 0, rz = -fx;
  const rl = Math.hypot(rx,ry,rz); rx/=rl; ry/=rl; rz/=rl;
  const ux = ry * fz - rz * fy, uy = rz * fx - rx * fz, uz = rx * fy - ry * fx;
  return { pos:[camX,camY,camZ], forward:[fx,fy,fz], right:[rx,ry,rz], up:[ux,uy,uz] };
}
let camBasis = computeCam();
let dragging=false, lastX=0, lastY=0;
canvas.addEventListener('mousedown', e => { dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', ()=> { dragging=false; });
window.addEventListener('mousemove', e => {
  if(!dragging) return;
  const dx = (e.clientX - lastX) * 0.005;
  const dy = (e.clientY - lastY) * 0.005;
  cam.azi -= dx;
  cam.ele = Math.max(-1.5, Math.min(1.5, cam.ele + dy));
  lastX = e.clientX; lastY = e.clientY;
  camBasis = computeCam();
  frameCount = 0;
});
canvas.addEventListener('wheel', e => { e.preventDefault(); cam.dist = Math.max(2, Math.min(20, cam.dist + e.deltaY * 0.01)); camBasis = computeCam(); frameCount = 0; }, {passive:false});

// accumulation ping-pong indexes
let curIdx = 0, nextIdx = 1;
let frameCount = 0;

// initialize and start
resize();

function render(){
  const cw = canvas.width, ch = canvas.height;

  // 1) SAMPLE+ACCUMULATE: read accum[curIdx], write accum[nextIdx]
  gl.bindFramebuffer(gl.FRAMEBUFFER, accumFBO);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, accumTex[nextIdx], 0);
  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
    console.error("FBO not complete");
    msg.textContent = "FBO incomplete";
    return;
  }

  gl.viewport(0,0,cw,ch);
  gl.useProgram(progSample);
  bindQuadAttribs(gl, progSample);

  // bind prev accumulation as texture unit 0
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, accumTex[curIdx]);
  gl.uniform1i(gl.getUniformLocation(progSample, "u_prevAccum"), 0);

  gl.uniform2f(gl.getUniformLocation(progSample, "u_resolution"), cw, ch);
  gl.uniform1i(gl.getUniformLocation(progSample, "u_frame"), frameCount);

  // camera uniforms
  gl.uniform3fv(gl.getUniformLocation(progSample, "u_camPos"), camBasis.pos);
  gl.uniform3fv(gl.getUniformLocation(progSample, "u_camForward"), camBasis.forward);
  gl.uniform3fv(gl.getUniformLocation(progSample, "u_camRight"), camBasis.right);
  gl.uniform3fv(gl.getUniformLocation(progSample, "u_camUp"), camBasis.up);
  gl.uniform1f(gl.getUniformLocation(progSample, "u_fov"), 0.9);
  gl.uniform1f(gl.getUniformLocation(progSample, "u_aspect"), cw / ch);

  // scene uniforms already set (spheres etc)
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // 2) DISPLAY: sample accumTex[nextIdx] (the latest accumulation)
  gl.viewport(0,0,cw,ch);
  gl.useProgram(progDisplay);
  bindQuadAttribs(gl, progDisplay);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, accumTex[nextIdx]);
  gl.uniform1i(gl.getUniformLocation(progDisplay, "u_accum"), 0);
  gl.uniform1i(gl.getUniformLocation(progDisplay, "u_frame"), frameCount + 1);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // swap
  curIdx = nextIdx;
  nextIdx = 1 - curIdx;
  frameCount++;

  msg.textContent = `Frame: ${frameCount} — ${Math.round(cw/(window.devicePixelRatio||1))}×${Math.round(ch/(window.devicePixelRatio||1))} px`;

  requestAnimationFrame(render);
}

// let GL errors get logged and start rendering
try {
  requestAnimationFrame(render);
} catch(e){
  console.error(e);
  msg.textContent = "Render failed: " + e.message;
}
</script>
</body>
</html>
