<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PathTracer</title>
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; }
  canvas { display:block; width:100%; height:100%; }
  #ui {
    position:fixed; left:12px; top:12px; color:#ddd; font-family: 'Segoe UI', monospace;
    background:rgba(20,20,20,0.9); padding:12px 16px; border-radius:8px; font-size:13px;
    backdrop-filter: blur(10px); border:1px solid rgba(255,255,255,0.15);
    pointer-events: none; user-select: none;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  }
  .row { display:flex; justify-content:space-between; margin-bottom:4px; min-width: 160px; }
  .label { color:#888; }
  .val { color:#fff; font-weight:bold; }
  .sub { font-size:11px; color:#666; margin-top:2px; }
  .status { margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1); font-size:11px; color:#aaa; }
  #error {
    position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
    background:rgba(200,50,50,0.9); color:white; padding:20px; border-radius:8px;
    font-family:sans-serif; text-align:center; display:none;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="ui">
  <div class="row"><span class="label">FPS:</span><span id="fpsVal" class="val">60</span></div>
  <div class="row"><span class="label">Samples:</span><span id="frameVal" class="val">0</span></div>
  <div class="sub">Shadow-Optimized Denoising</div>
  <div class="status">Status: <span id="denoiseStatus" style="color:#4f4">Stabilizing</span></div>
</div>
<div id="error"></div>

<script>
/* GPU Path Tracer with Advanced Shadow Denoising
   -------------------------------------------------
   Fixes:
   1. Adaptive Sigma: Bilateral filter blurs more in dark regions where noise is prominent.
   2. Outlier Removal: Suppresses "fireflies" in the display pass.
   3. Stable Reprojection: Keeps pixels "stuck" longer if the camera movement is sub-pixel.
*/

const MAX_SPHERES = 8;
const MAX_LIGHTS = 4;

// --- Scene Setup ---
const Spheres = [
  { cx: 0, cy: 0.5, cz: -0.5, rad: 1.0, mat: 0 },
  { cx: 1.8, cy: 0.2, cz: 0.5,  rad: 0.7, mat: 1 },
  { cx:-1.8, cy: 0.2, cz: 0.0,  rad: 0.7, mat: 2 }
];
const Plane = { y: -0.5, mat: 3 };
const Materials = [
  { r:0.9, g:0.2, b:0.2 }, // Red
  { r:0.7, g:0.7, b:0.7 }, // Grey
  { r:0.2, g:0.3, b:0.9 }, // Blue
  { r:0.9, g:0.9, b:0.9 }, // Floor
  { r:0.1, g:0.1, b:0.1 }  // Dark
];
const Lights = [
  { x: 0.0, y: 4.0, z: 2.0, rad: 0.8, r: 40.0, g: 30.0, b: 25.0 }, 
  { x:-5, y:8, z:5, rad:1.5, r:15, g:15, b:15 },
  { x: 5, y:5, z:2, rad:1.0, r:5, g:5, b:5 }
];

const canvas = document.getElementById('glcanvas');
const uiFps = document.getElementById('fpsVal');
const uiFrame = document.getElementById('frameVal');
const uiDenoise = document.getElementById('denoiseStatus');
const errorBox = document.getElementById('error');

function showError(msg) {
  errorBox.style.display = 'block';
  errorBox.textContent = msg;
}

// Init WebGL2
let gl = canvas.getContext('webgl2', { antialias:false, powerPreference:'high-performance' });
if (!gl) { showError('WebGL2 required'); throw new Error('No WebGL2'); }

const extColorFloat = gl.getExtension('EXT_color_buffer_float');
const extFloatLinear = gl.getExtension('OES_texture_float_linear');
const extHalfFloatLinear = gl.getExtension('OES_texture_half_float_linear');

// --- Matrix Math Helpers ---
const Mat4 = {
  create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
  copy: (out, a) => { out.set(a); return out; },
  perspective: (out, fovy, aspect, near, far) => {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    out[0] = f / aspect; out[1]=0; out[2]=0; out[3]=0;
    out[4]=0; out[5]=f; out[6]=0; out[7]=0;
    out[8]=0; out[9]=0; out[10]=(far + near) * nf; out[11]=-1;
    out[12]=0; out[13]=0; out[14]=(2 * far * near) * nf; out[15]=0;
    return out;
  },
  lookAt: (out, eye, center, up) => {
    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    let eyex = eye[0], eyey = eye[1], eyez = eye[2];
    let upx = up[0], upy = up[1], upz = up[2];
    let centerx = center[0], centery = center[1], centerz = center[2];
    z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len; z1 *= len; z2 *= len;
    x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
    y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
    out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
    out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
    out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  },
  multiply: (out, a, b) => {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30; out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32; out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30; out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32; out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30; out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32; out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30; out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32; out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
  }
};

const vertSrc = `#version 300 es
layout(location=0) in vec2 a_pos;
out vec2 v_uv;
void main(){ v_uv = 0.5*(a_pos+1.0); gl_Position = vec4(a_pos,0.0,1.0); }`;

const fragTraceSrc = `#version 300 es
precision highp float;
precision highp int;

layout(location=0) out vec4 outColor; 

in vec2 v_uv;

uniform sampler2D u_prevAccum;
uniform int u_frame;       
uniform int u_motionFrame; 
uniform vec2 u_resolution;
uniform float u_time;

uniform vec3 u_camPos;
uniform vec3 u_camF; 
uniform vec3 u_camR; 
uniform vec3 u_camU; 

uniform vec3 u_prevCamPos;
uniform mat4 u_prevViewProj;

uniform int u_sphereCount;
uniform vec4 u_spheres[${MAX_SPHERES}];
uniform int u_sphereMat[${MAX_SPHERES}];
uniform float u_planeY;
uniform int u_planeMat;

uniform int u_materialCount;
uniform vec3 u_materials[${Materials.length}];

uniform int u_lightCount;
uniform vec4 u_lights[${MAX_LIGHTS}];
uniform vec3 u_lightCols[${MAX_LIGHTS}];

#define PI 3.14159265359

uint hash_u(uint x){ x += (x<<10u); x ^= (x>>6u); x += (x<<3u); x ^= (x>>11u); x += (x<<15u); return x; }
float rnd(inout uint s){ s = hash_u(s); return float(s & 0x00FFFFFFu) / float(0x01000000u); }
uint seed_from(ivec2 p, int frame, float t) {
  uint x = uint(p.x) * 73856093u;
  uint y = uint(p.y) * 19349663u;
  uint f = uint(frame) * 83492791u;
  return hash_u(x ^ y ^ f ^ floatBitsToUint(t));
}

struct Hit { float t; vec3 p; vec3 n; int mat; };

Hit intersectScene(vec3 ro, vec3 rd) {
  Hit h; h.t = 1e20; h.mat = -1;
  for (int i=0; i<u_sphereCount; ++i) {
    vec4 s = u_spheres[i];
    vec3 oc = s.xyz - ro;
    float b = dot(oc, rd);
    float det = b*b - dot(oc,oc) + s.w*s.w;
    if (det < 0.0) continue;
    float t = b - sqrt(det);
    if (t > 0.001 && t < h.t) {
      h.t = t; h.p = ro + rd*t; 
      h.n = normalize(h.p - s.xyz);
      h.mat = u_sphereMat[i];
    }
  }
  if (rd.y < 0.0) {
    float tp = (u_planeY - ro.y) / rd.y;
    if (tp > 0.001 && tp < h.t) {
      h.t = tp; h.p = ro + rd*tp; 
      h.n = vec3(0.0,1.0,0.0); 
      h.mat = u_planeMat;
    }
  }
  return h;
}

bool occluded(vec3 ro, vec3 rd, float maxDist) {
  for (int i=0; i<u_sphereCount; ++i) {
    vec4 s = u_spheres[i];
    vec3 oc = s.xyz - ro;
    float b = dot(oc, rd);
    float det = b*b - dot(oc,oc) + s.w*s.w;
    if (det > 0.0) {
      float t = b - sqrt(det);
      if (t > 0.001 && t < maxDist) return true;
    }
  }
  if (rd.y < 0.0) {
    float tp = (u_planeY - ro.y) / rd.y;
    if (tp > 0.001 && tp < maxDist) return true;
  }
  return false;
}

vec3 sampleHemisphere(vec3 n, float r1, float r2) {
  float phi = 2.0 * PI * r1;
  float r = sqrt(r2);
  float x = cos(phi) * r;
  float y = sin(phi) * r;
  float z = sqrt(max(0.0, 1.0 - r2));
  vec3 up = abs(n.y) < 0.99 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,0.0);
  vec3 t = normalize(cross(up, n));
  vec3 b = cross(n, t);
  return normalize(t * x + b * y + n * z);
}

void main(){
  ivec2 pix = ivec2(gl_FragCoord.xy);
  uint state = seed_from(pix, u_frame, u_time);
  vec2 uvJ = (gl_FragCoord.xy + vec2(rnd(state), rnd(state))) / u_resolution;
  vec3 rd = normalize(u_camF + u_camR * (uvJ.x - 0.5) + u_camU * (uvJ.y - 0.5));
  vec3 ro = u_camPos;
  
  vec3 accum = vec3(0.0);
  vec3 throughput = vec3(1.0);
  float firstHitDist = 1e20;
  bool hitSomething = false;

  for (int bounce=0; bounce<3; ++bounce) {
    Hit h = intersectScene(ro, rd);
    if (bounce == 0) firstHitDist = h.t;
    if (h.t > 1e19) {
      float skyT = 0.5 * (rd.y + 1.0);
      accum += throughput * vec3(0.4, 0.5, 0.7) * skyT;
      break;
    }
    hitSomething = true;
    vec3 matCol = u_materials[clamp(h.mat, 0, u_materialCount-1)];
    vec3 nextRo = h.p + h.n * 0.001;
    
    // Light Sampling
    for (int li=0; li<u_lightCount; ++li) {
      vec4 L = u_lights[li];
      vec3 lSamp = L.xyz + L.w * normalize(vec3(rnd(state)-0.5, rnd(state)-0.5, rnd(state)-0.5));
      vec3 toL = lSamp - nextRo;
      float dist2 = dot(toL,toL);
      float dist = sqrt(dist2);
      vec3 Ldir = toL / dist;
      float nl = max(0.0, dot(h.n, Ldir));
      if (nl > 0.0 && !occluded(nextRo, Ldir, dist - 0.01)) {
        accum += throughput * matCol * u_lightCols[li] * nl / (dist2 + 1.0);
      }
    }
    rd = sampleHemisphere(h.n, rnd(state), rnd(state));
    ro = nextRo; throughput *= matCol;
    if (bounce >= 1) {
      float p = max(throughput.r, max(throughput.g, throughput.b));
      if (rnd(state) > p) break;
      throughput /= max(1e-6, p);
    }
  }
  
  vec3 currentRadiance = min(accum, vec3(12.0)); // Tighter clamp for shadow stability
  vec3 worldPos = u_camPos + normalize(u_camF + u_camR * (v_uv.x - 0.5) + u_camU * (v_uv.y - 0.5)) * firstHitDist;

  // Temporal Logic
  bool isValid = false;
  vec3 historyColor = vec3(0.0);
  float blendFactor = 1.0; 

  if (hitSomething && u_frame > 0) {
      vec4 prevClip = u_prevViewProj * vec4(worldPos, 1.0);
      if (prevClip.w > 0.0) {
          vec2 prevUV = (prevClip.xy / prevClip.w) * 0.5 + 0.5;
          if (prevUV.x >= 0.0 && prevUV.x <= 1.0 && prevUV.y >= 0.0 && prevUV.y <= 1.0) {
              vec4 historySample = texture(u_prevAccum, prevUV);
              float distToPrevCam = distance(u_prevCamPos, worldPos);
              if (abs(historySample.a - distToPrevCam) < 0.03 * distToPrevCam) {
                  isValid = true;
                  historyColor = historySample.rgb;
                  float velocity = length(prevUV - v_uv);
                  if (velocity < 0.00005) {
                      blendFactor = 1.0 / min(float(u_motionFrame) + 1.0, 128.0);
                  } else {
                      blendFactor = 0.12; // Slower blend for smoother movement
                  }
              }
          }
      }
  }
  vec3 result = isValid ? mix(historyColor, currentRadiance, blendFactor) : currentRadiance;
  outColor = vec4(result, firstHitDist);
}
`;

const fragDisplaySrc = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;

uniform sampler2D u_accum;
uniform vec2 u_resolution;

float getLuma(vec3 c) { return dot(c, vec3(0.299, 0.587, 0.114)); }

void main(){
  ivec2 coord = ivec2(gl_FragCoord.xy);
  vec3 centerVal = texelFetch(u_accum, coord, 0).rgb;
  float centerLuma = getLuma(centerVal);

  // Outlier Suppression (Firefly filter)
  // Check neighbors to see if center is way too bright
  vec3 m1 = vec3(0.0);
  vec3 m2 = vec3(0.0);
  for(int x=-1; x<=1; x++) {
      for(int y=-1; y<=1; y++) {
          vec3 val = texelFetch(u_accum, coord + ivec2(x,y), 0).rgb;
          m1 += val;
          m2 += val * val;
      }
  }
  vec3 mean = m1 / 9.0;
  vec3 std = sqrt(max(vec3(0.0), (m2 / 9.0) - mean * mean));
  centerVal = clamp(centerVal, mean - std * 3.0, mean + std * 3.0);

  // ADAPTIVE BILATERAL FILTER
  // sigmaColor should be larger in dark areas (shadows) to allow more blurring of noise
  float sigmaSpace = 2.5;
  float sigmaColor = mix(0.6, 0.15, smoothstep(0.0, 0.4, centerLuma)); 
  
  vec3 sum = vec3(0.0);
  float wSum = 0.0;
  
  // 7x7 Optimized Kernel
  for(int x=-3; x<=3; ++x){
    for(int y=-3; y<=3; ++y){
      vec3 tapVal = texelFetch(u_accum, coord + ivec2(x,y), 0).rgb;
      float d2 = float(x*x + y*y);
      float wSpace = exp(-d2 / (2.0 * sigmaSpace * sigmaSpace));
      
      float lumaTap = getLuma(tapVal);
      float lDiff = lumaTap - centerLuma;
      float wColor = exp(-(lDiff*lDiff) / (2.0 * sigmaColor * sigmaColor));
      
      float w = wSpace * wColor;
      sum += tapVal * w;
      wSum += w;
    }
  }
  
  vec3 finalColor = (wSum > 0.0) ? sum / wSum : centerVal;
  fragColor = vec4(pow(finalColor, vec3(1.0/2.2)), 1.0);
}
`;

function compile(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
function link(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}

const vs = compile(vertSrc, gl.VERTEX_SHADER);
const fsTrace = compile(fragTraceSrc, gl.FRAGMENT_SHADER);
const fsDisplay = compile(fragDisplaySrc, gl.FRAGMENT_SHADER);
const progTrace = link(vs, fsTrace);
const progDisplay = link(vs, fsDisplay);

const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

const locTrace = {
  prev: gl.getUniformLocation(progTrace, 'u_prevAccum'),
  frame: gl.getUniformLocation(progTrace, 'u_frame'),
  motionFrame: gl.getUniformLocation(progTrace, 'u_motionFrame'),
  res: gl.getUniformLocation(progTrace, 'u_resolution'),
  time: gl.getUniformLocation(progTrace, 'u_time'),
  camPos: gl.getUniformLocation(progTrace, 'u_camPos'),
  camF: gl.getUniformLocation(progTrace, 'u_camF'),
  camR: gl.getUniformLocation(progTrace, 'u_camR'),
  camU: gl.getUniformLocation(progTrace, 'u_camU'),
  prevCamPos: gl.getUniformLocation(progTrace, 'u_prevCamPos'),
  prevViewProj: gl.getUniformLocation(progTrace, 'u_prevViewProj'),
};
const locDisplay = {
  accum: gl.getUniformLocation(progDisplay, 'u_accum'),
  res: gl.getUniformLocation(progDisplay, 'u_resolution')
};

let texCol = [null, null], fb = [null, null];
let width=0, height=0;

function initBuffers(w, h) {
  width = w; height = h;
  for(let i=0; i<2; i++) {
    if (texCol[i]) { gl.deleteTexture(texCol[i]); gl.deleteFramebuffer(fb[i]); }
    texCol[i] = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texCol[i]);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, w, h, 0, gl.RGBA, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    fb[i] = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb[i]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texCol[i], 0);
  }
}

let frame = 0;
let motionFrame = 0;
let camState = { dist: 7.0, azi: 2.1, ele: 0.4, target: [0,0.2,0] };
let camVecs = { pos:[0,0,0], f:[0,0,0], r:[0,0,0], u:[0,0,0] };
let viewProj = Mat4.create();
let lastRenderedViewProj = Mat4.create();
let lastRenderedCamPos = new Float32Array(3);

function updateMatrix() {
  const eye = camVecs.pos;
  const center = [eye[0]+camVecs.f[0], eye[1]+camVecs.f[1], eye[2]+camVecs.f[2]];
  const view = Mat4.create();
  Mat4.lookAt(view, eye, center, [0,1,0]);
  const proj = Mat4.create();
  Mat4.perspective(proj, 60 * PI/180, width/height, 0.1, 100.0);
  Mat4.multiply(viewProj, proj, view);
}

function updateCamVecs(forceReset = false) {
  const y = camState.dist * Math.sin(camState.ele);
  const r = camState.dist * Math.cos(camState.ele);
  camVecs.pos = [camState.target[0] + r * Math.sin(camState.azi), camState.target[1] + y, camState.target[2] + r * Math.cos(camState.azi)];
  const fRaw = [camState.target[0]-camVecs.pos[0], camState.target[1]-camVecs.pos[1], camState.target[2]-camVecs.pos[2]];
  const fLen = Math.hypot(...fRaw);
  const f = fRaw.map(v=>v/fLen);
  let rRaw = [f[1]*0 - f[2]*1, f[2]*0 - f[0]*0, f[0]*1 - f[1]*0];
  if (Math.hypot(...rRaw)<0.01) rRaw=[1,0,0];
  const rLen = Math.hypot(...rRaw);
  const rgt = rRaw.map(v=>v/rLen);
  let uRaw = [rgt[1]*f[2] - rgt[2]*f[1], rgt[2]*f[0] - rgt[0]*f[2], rgt[0]*f[1] - rgt[1]*f[0]];
  const uLen = Math.hypot(...uRaw);
  const uNorm = uRaw.map(v=>v/uLen);
  const vpH = 2 * Math.tan((60 * PI/180)/2);
  const vpW = vpH * (width/height);
  camVecs.f = f; camVecs.r = rgt.map(v=>v*vpW); camVecs.u = uNorm.map(v=>v*vpH);
  updateMatrix();
  if (forceReset) { frame = 0; motionFrame = 0; Mat4.copy(lastRenderedViewProj, viewProj); lastRenderedCamPos.set(camVecs.pos); }
  else { motionFrame = 0; }
}

const PI = Math.PI;
let dragging = false, lx=0, ly=0;
canvas.addEventListener('mousedown', e=>{ dragging=true; lx=e.clientX; ly=e.clientY; });
window.addEventListener('mouseup', ()=>dragging=false);
canvas.addEventListener('mousemove', e=>{
  if (dragging) {
    camState.azi -= (e.clientX - lx) * 0.005; 
    camState.ele = Math.max(-1.5, Math.min(1.5, camState.ele + (e.clientY - ly) * 0.005));
    lx = e.clientX; ly = e.clientY; updateCamVecs(false); 
  }
});

function setUniforms() {
  const p = progTrace;
  gl.uniform1i(gl.getUniformLocation(p, 'u_sphereCount'), Spheres.length);
  Spheres.forEach((s,i) => {
    gl.uniform4f(gl.getUniformLocation(p, `u_spheres[${i}]`), s.cx,s.cy,s.cz,s.rad);
    gl.uniform1i(gl.getUniformLocation(p, `u_sphereMat[${i}]`), s.mat);
  });
  gl.uniform1f(gl.getUniformLocation(p, 'u_planeY'), Plane.y);
  gl.uniform1i(gl.getUniformLocation(p, 'u_planeMat'), Plane.mat);
  gl.uniform1i(gl.getUniformLocation(p, 'u_materialCount'), Materials.length);
  Materials.forEach((m,i) => gl.uniform3f(gl.getUniformLocation(p, `u_materials[${i}]`), m.r, m.g, m.b));
  gl.uniform1i(gl.getUniformLocation(p, 'u_lightCount'), Lights.length);
  Lights.forEach((l,i) => {
    gl.uniform4f(gl.getUniformLocation(p, `u_lights[${i}]`), l.x, l.y, l.z, l.rad);
    gl.uniform3f(gl.getUniformLocation(p, `u_lightCols[${i}]`), l.r, l.g, l.b);
  });
}

let ping = 0;
function draw() {
  const pong = 1 - ping;
  gl.useProgram(progTrace);
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb[ping]);
  gl.viewport(0,0,width,height);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texCol[pong]);
  gl.uniform1i(locTrace.prev, 0);
  gl.uniform1i(locTrace.frame, frame);
  gl.uniform1i(locTrace.motionFrame, motionFrame);
  gl.uniform2f(locTrace.res, width, height);
  gl.uniform1f(locTrace.time, performance.now()*0.001);
  gl.uniform3fv(locTrace.camPos, camVecs.pos);
  gl.uniform3fv(locTrace.camF, camVecs.f);
  gl.uniform3fv(locTrace.camR, camVecs.r);
  gl.uniform3fv(locTrace.camU, camVecs.u);
  gl.uniform3fv(locTrace.prevCamPos, lastRenderedCamPos);
  gl.uniformMatrix4fv(locTrace.prevViewProj, false, lastRenderedViewProj);
  setUniforms();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(0);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  gl.useProgram(progDisplay);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,width,height);
  gl.bindTexture(gl.TEXTURE_2D, texCol[ping]); 
  gl.uniform1i(locDisplay.accum, 0);
  gl.uniform2f(locDisplay.res, width, height);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  frame++; motionFrame++; ping = pong;
  Mat4.copy(lastRenderedViewProj, viewProj);
  lastRenderedCamPos.set(camVecs.pos);
  uiFrame.textContent = frame;
  requestAnimationFrame(draw);
}

function onResize() {
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
  initBuffers(canvas.width, canvas.height); updateCamVecs(true);
}
window.addEventListener('resize', onResize);
onResize();
requestAnimationFrame(draw);
</script>
</body>
</html>
